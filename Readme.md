# Как настроить проект
## Базовая структура каталогов
После выполнения следующих шагов структура каталогов нашего приложения будет выглядеть следующим образом:

flask-докер

├── app.py

├── Файл Dockerfile

├── requirements.txt

└── venv

В этом разделе мы рассмотрим, как создать приложение со структурой, подобной показанной выше. Вы можете найти подробное руководство по созданию или установке этого проекта здесь.

Предполагая, что вы правильно следовали инструкциям по установке и у вас установлена активная виртуальная среда с Flask, теперь мы изменим два файла, созданные в GitHub readme, следующим образом.

## Как изменить app.py
Давайте добавим следующие строки кода в наш app.py:


```from flask import Flask
from flask import Flask, render_template

app = Flask(__name__)

@app.route('/main/')
def hello_world2():
    return 'Moe Flask приложение в контейнере Docker.'

@app.route('/')
def hello_world():
    return render_template('index.html')

if __name__ == '__main__':
    app.run()
 ```

Теперь, если мы запустим python app.py в командной строке для тестирования нашего приложения Flask мы должны получить результаты, аналогичные приведенным ниже:

``` * Serving Flask app 'app' (lazy loading)
 * Environment: production
   WARNING: This is a development server. Do not use it in a production deployment.
   Use a production WSGI server instead.
 * Debug mode: on
 * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
 * Restarting with stat
 * Debugger is active!
 * Debugger PIN: 316-584-348
 ```

## Как изменить файл Dockerfile
# syntax=docker/dockerfile:1
```
# Официальный образ Python
FROM python:3.8-slim-buster

# Установка зависимостей
COPY requirements.txt .
RUN pip install -r requirements.txt
RUN pip install gunicorn
# Копирование приложения в контейнер
COPY app.py .
COPY templates templates

# Открытие порта, на котором будет запущено приложение
EXPOSE 5000

# Запуск приложения при старте контейнера
#CMD [ "python", "app.py" ]
CMD ["gunicorn",  "-b",  "0.0.0.0:5000", "app:app"]
```
Прежде чем мы создадим образ для только что созданного приложения, давайте сначала поймем, что означают строки кода в приведенном выше файле Docker и какую роль они играют.

Приведенный ниже код должен быть первой строкой каждого файла Docker – он сообщает разработчику Docker, какой синтаксис использовать при разборе файла Docker, и местоположение файла синтаксиса Docker. (Источник)

# syntax=docker/dockerfile:1
Хотя можно создавать наши собственные базовые образы, нет необходимости заходить так далеко, потому что Docker позволяет нам наследовать существующие образы. Следующая строка сообщает Docker, какой базовый образ использовать — в данном случае, образ Python.

```FROM python:3.8-slim-buster```

Чтобы все было организовано, мы также указываем Docker, какую папку использовать для остальных операций, поэтому мы используем относительный путь, как показано ниже.

В этом случае мы говорим Docker использовать тот же каталог и имя для остальных своих операций — это каталог, содержащийся в нашем образе контейнера.

```WORKDIR /python-docker```

В четвертой и пятой строках мы говорим Docker скопировать содержимое нашего requirements.txt вложите файл в изображение контейнера в requirements.txt файл. Затем запустите pip install, чтобы установить все зависимости в том же файле, который будет использоваться образом.

```
COPY requirements.txt requirements.txt
RUN pip3 install -r requirements.txt
```

Продолжая копирование, теперь мы копируем остальные файлы из нашего локального рабочего каталога в каталог в образе docker.

```COPY . .```

docker-иллюстрация
На данный момент в нашем изображении есть все файлы, похожие на те, что находятся в нашем локальном рабочем каталоге. Наша следующая задача - помочь Docker понять, как запустить этот образ внутри контейнера.

Эта строка конкретно предписывает Docker запустить наше приложение Flask в виде модуля, как указано тегом "-m". Затем он инструктирует Docker сделать контейнер доступным извне, например, из нашего браузера, а не только изнутри контейнера. Мы передаем порт хоста:

```CMD [ "python3", "-m" , "flask", "run", "--host=0.0.0.0"]```
Поскольку у нас было,

```if __name__ == "__main__":
    app.run(debug=True)
   ```
Поскольку у нас была инструкция "if" в файле нашего приложения, это будет верно, если мы запустим этот модуль как отдельную программу. В результате оно может функционировать как модуль, импортированный другой программой, или как автономная программа, но оно будет выполнять код в инструкции if только в том случае, если выполняется как программа. (Источник)

# Как создать образ Docker
После этого все, что остается, это создать наш образ. Используя docker build, теперь мы можем заручиться помощью Docker в создании образа. Вы можете объединить команду сборки с другими тегами, такими как флаг "--tag", чтобы указать имя изображения.

```docker build --tag python-docker .```
## Как запустить изображение в качестве контейнера
Запустить изображение внутри контейнера так же просто, как создать его. Но прежде чем мы это сделаем, мы хотели бы посмотреть, какие еще изображения доступны в нашей среде. Для просмотра изображений из командной строки выполните следующее:

docker images
Если приведенная выше команда обнаружит какие-либо изображения, результат должен выглядеть примерно так:
```
REPOSITORY      TAG       IMAGE ID       CREATED             SIZE
python-docker   latest    cd52b70b361a   About an hour ago   912MB
headless-cms    latest    e8b253e230ee   43 hours ago        937MB
scrappy         latest    3e7ac0d44890   7 weeks ago         904MB
python          3.9.2     587b1bc803b3   7 months ago        885MB
```
Теперь мы можем выбрать, какой образ запускать. Используя docker run команду, мы можем запустить изображение, передав имя изображения в качестве параметра.

```docker run```
При выполнении приведенной выше команды вы заметите, что в командной строке это указывает на то, что приложение запущено. Но когда вы вводите http://localhost:5000/ в браузере, приветствие будет:

Этот сайт недоступен, localhost отказался подключаться.
Независимо от того, запущен контейнер или нет, он выполняет это в режиме изоляции и не может подключиться к localhost: 5000.

Лучшее решение - запустить изображение в отключенном режиме. Поскольку нам нужно просматривать это приложение в браузере, а не в контейнере, мы изменим наш запуск docker и добавим два дополнительных тега: "-d", чтобы запустить его в отключенном режиме, и "-p", чтобы указать порт, который будет доступен.

Команда docker run теперь будет отформатирована следующим образом:

```docker run -d -p 5000:5000 python-docker```
На этот раз мы увидим следующий результат, если запустим его в отключенном режиме и посетим localhost через порт 5000:

d
Мы можем использовать следующую команду, чтобы увидеть, какие контейнеры запущены в данный момент:

```docker ps```
Результат выглядит следующим образом:

```CONTAINER ID   IMAGE           COMMAND                  CREATED         STATUS         PORTS                    NAMES
a173935297cd   python-docker   "python3 -m flask ru…"   5 minutes ago   Up 5 minutes   0.0.0.0:5000->5000/tcp   happy_wescoff
```
Чтобы остановить текущий запущенный контейнер, мы выполняем эту команду:

```docker stop <container-name>```
Еще одна полезная команда, которую следует иметь при работе с Docker, - это:

```docker container prune```
Это удаляет неиспользуемые ресурсы, освобождая место и поддерживая чистоту вашей системы.

И это все!